{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the functions project, an open source, curiosity-driven tool for optimizing the administration of function as a service (FaaS) technologies. Our purpose is to make it easier to build, maintain and deploy serverless functions. Resources \u00b6 GitHub: https://github.com/Katolus/functions PyPI: https://pypi.org/project/functions-cli/ Free software: MIT Features \u00b6 The project is still under deep development, and there is still much work to be done even to reach the base quality. Nonetheless, we believe there is value in using it as it is if it fits your needs and requirements (Python + Linux). Feedback, issues and request are more than welcome. See the road map to see how our vision might need your future interest. In the following sections, we list a summary of the functionalities that the tool can perform. Locally \u00b6 Generate new template function directories for starting new functions. Two types GCP http / pubsub . Add an existing function to the function registry to be run and deployed as functions native to the package. Build pre-generated, validated and locally existing functions using Docker. Operate ( deploy / remove ) Google Cloud Platform functions from a local machine. Store information about the built, run and deployed functions locally for reference and configuration. Print out information about functions and their statuses (Build/Deployed/Running) using the list command. Log function history using a log file stored on your local device. GCP \u00b6 Deploy locally existing functions as cloud functions. Limited to two types - http and pubsub . Delete functions deployed to GCP using this package. Additional Context \u00b6 Anyone interested in additional details is invited to view the extended source of documentation directly in Github. Proposals, ADRs for people seriously inquisitive about how we built this project.","title":"Introduction"},{"location":"#resources","text":"GitHub: https://github.com/Katolus/functions PyPI: https://pypi.org/project/functions-cli/ Free software: MIT","title":"Resources"},{"location":"#features","text":"The project is still under deep development, and there is still much work to be done even to reach the base quality. Nonetheless, we believe there is value in using it as it is if it fits your needs and requirements (Python + Linux). Feedback, issues and request are more than welcome. See the road map to see how our vision might need your future interest. In the following sections, we list a summary of the functionalities that the tool can perform.","title":"Features"},{"location":"#locally","text":"Generate new template function directories for starting new functions. Two types GCP http / pubsub . Add an existing function to the function registry to be run and deployed as functions native to the package. Build pre-generated, validated and locally existing functions using Docker. Operate ( deploy / remove ) Google Cloud Platform functions from a local machine. Store information about the built, run and deployed functions locally for reference and configuration. Print out information about functions and their statuses (Build/Deployed/Running) using the list command. Log function history using a log file stored on your local device.","title":"Locally"},{"location":"#gcp","text":"Deploy locally existing functions as cloud functions. Limited to two types - http and pubsub . Delete functions deployed to GCP using this package.","title":"GCP"},{"location":"#additional-context","text":"Anyone interested in additional details is invited to view the extended source of documentation directly in Github. Proposals, ADRs for people seriously inquisitive about how we built this project.","title":"Additional Context"},{"location":"idea/","text":"Here you can find additional context on purpose behind making this project and some of its criteria, expectations and scope. Quick Pitch \u00b6 functions - a command line tool that helps manage functions as a service (FaaS) components locally and remotely. Background \u00b6 If you are a developer working with any cloud providers, the chance is, you would have heard about serverless functions. You can use them to run small, independent components that can scale on demand. Their scope is usually that of a single task. Examples include: building a single point API, building a triggered pipeline, connecting to a resource etc... It is a fantastic piece of technology that can decouple large systems and support a wide variety of cases. Generally, it is easy to deploy a simple serverless function as a template version to fit your basic needs. It gets a little more complicated if you face a task that is out of the ordinary. Questions emerge. How do you keep track of your work? What was deployed or what was run. How do you deploy the function? How do you test it? It is not easy to handle all that using a standard tool like the gcloud command-line tool, and it is not even close to being fast. Usually, you need to deploy the function to see any results. Some providers offer helpful libraries/tools that allow you to run your serverless functions locally, but even that quickly gets complicated and requires you to learn another repository and its documentation. Even if you pass through, the automations you built will be highly specific to the provider you are using by which you are locked in. One of the things that made HashiCorp products so great is that they allow for flexibility. Flexibility and modularity are becoming far more important nowadays than it ever was. In an attempt to tackle all these pain-points and make any serverless task a much more fun experience, we propose building a software tool that takes care of all the local environment, deployment, tracking, logging and provider-specific logic and gives a developer a homogeneous CLI interface to interact with their FaaS components. A tool that takes away the complexity and gives back an intuitive work tool for everyone to use. Progress so far \u00b6 The project started as a solo project in between jobs. It's scope was massively undercut from the start, but with time and experience, the spectrum became something that we can track with much higher confidence. The project is a battleground for growing developer skills, and it has been treated like that, still yet to see its first release. Objectives \u00b6 Fail and learn. Experiment and test out various ideas. Provide value to at least one person. Get people interested. Principle Values \u00b6 Easy to Use. Safe. Simple. Timeframe \u00b6 Stage Summary Delivery First Release The first release targets a stable alpha version with enough functionalities to test the idea in action. Planned for the end of 2021 Engineering budget \u00b6 In the first stage, the project is being developed by a single person as a side project between jobs. Since that person has other commitments, the project has taken a lower priority, and work on it goes slower than anticipated. So if you believe in this project, the repository is set up to support community contributions if people value it enough to contribute. Monitoring and Evaluation \u00b6 The project is being reviewed at least every month to reevaluate timeframes, view project interactions and adjust documentation accordingly. Lessons learned \u00b6 Beyond elemental learnings such as how to pick a suitable license or which tool to use to perform a specific task, here lay the lessons with a broader, more generic scope: It takes a lot of time, effort and brainpower to build a quality project. The scope is always bigger than you initially thought to be. It is vital to build and bring tools to the project. Planning out the scope and writing a comprehensive overview is reasonably the most crucial step. Otherwise, you are unsure what you are trying to do or how the project should be structured. It is worth the effort . Documentation is as important if not more important than code.","title":"Idea"},{"location":"idea/#quick-pitch","text":"functions - a command line tool that helps manage functions as a service (FaaS) components locally and remotely.","title":"Quick Pitch"},{"location":"idea/#background","text":"If you are a developer working with any cloud providers, the chance is, you would have heard about serverless functions. You can use them to run small, independent components that can scale on demand. Their scope is usually that of a single task. Examples include: building a single point API, building a triggered pipeline, connecting to a resource etc... It is a fantastic piece of technology that can decouple large systems and support a wide variety of cases. Generally, it is easy to deploy a simple serverless function as a template version to fit your basic needs. It gets a little more complicated if you face a task that is out of the ordinary. Questions emerge. How do you keep track of your work? What was deployed or what was run. How do you deploy the function? How do you test it? It is not easy to handle all that using a standard tool like the gcloud command-line tool, and it is not even close to being fast. Usually, you need to deploy the function to see any results. Some providers offer helpful libraries/tools that allow you to run your serverless functions locally, but even that quickly gets complicated and requires you to learn another repository and its documentation. Even if you pass through, the automations you built will be highly specific to the provider you are using by which you are locked in. One of the things that made HashiCorp products so great is that they allow for flexibility. Flexibility and modularity are becoming far more important nowadays than it ever was. In an attempt to tackle all these pain-points and make any serverless task a much more fun experience, we propose building a software tool that takes care of all the local environment, deployment, tracking, logging and provider-specific logic and gives a developer a homogeneous CLI interface to interact with their FaaS components. A tool that takes away the complexity and gives back an intuitive work tool for everyone to use.","title":"Background"},{"location":"idea/#progress-so-far","text":"The project started as a solo project in between jobs. It's scope was massively undercut from the start, but with time and experience, the spectrum became something that we can track with much higher confidence. The project is a battleground for growing developer skills, and it has been treated like that, still yet to see its first release.","title":"Progress so far"},{"location":"idea/#objectives","text":"Fail and learn. Experiment and test out various ideas. Provide value to at least one person. Get people interested.","title":"Objectives"},{"location":"idea/#principle-values","text":"Easy to Use. Safe. Simple.","title":"Principle Values"},{"location":"idea/#timeframe","text":"Stage Summary Delivery First Release The first release targets a stable alpha version with enough functionalities to test the idea in action. Planned for the end of 2021","title":"Timeframe"},{"location":"idea/#engineering-budget","text":"In the first stage, the project is being developed by a single person as a side project between jobs. Since that person has other commitments, the project has taken a lower priority, and work on it goes slower than anticipated. So if you believe in this project, the repository is set up to support community contributions if people value it enough to contribute.","title":"Engineering budget"},{"location":"idea/#monitoring-and-evaluation","text":"The project is being reviewed at least every month to reevaluate timeframes, view project interactions and adjust documentation accordingly.","title":"Monitoring and Evaluation"},{"location":"idea/#lessons-learned","text":"Beyond elemental learnings such as how to pick a suitable license or which tool to use to perform a specific task, here lay the lessons with a broader, more generic scope: It takes a lot of time, effort and brainpower to build a quality project. The scope is always bigger than you initially thought to be. It is vital to build and bring tools to the project. Planning out the scope and writing a comprehensive overview is reasonably the most crucial step. Otherwise, you are unsure what you are trying to do or how the project should be structured. It is worth the effort . Documentation is as important if not more important than code.","title":"Lessons learned"},{"location":"roadmap/","text":"To understand what this project is about, check out the idea section. Currently, the functions project is curated by the author, so please consider contributing. All input is welcomed. The main goal is to provide a valuable, tested, and robust tool that others can use to their benefit. You can follow a more detailed, documented path via the project page . Once we reach the base quality and the project gets traction, we plan to grow its capabilities. Topics/features include: Add AWS support. Add support for GitHub URL as a source path for a function. Enhance support for runtimes other than python. Custom commands and scripts. Initialise and lead test coverage. And more to come as the tool starts to get used in actual implementations.","title":"Roadmap"}]}