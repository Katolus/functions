{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to the functions project, an open source, curiosity-driven tool for optimizing the administration of function as a service (FaaS) technologies. Our purpose is to make it easier to build, maintain and deploy serverless functions. Resources \u00b6 GitHub: https://github.com/Katolus/functions PyPI: https://pypi.org/project/functions-cli/ License: MIT Features \u00b6 The project is still under deep development, and there is still much work to be done even to reach the base quality. Nonetheless, we believe there is value in using it as it is if it fits your needs and requirements (Python + Linux). Feedback, issues and request are more than welcome. See the road map to see how our vision might need your future interest. In the following sections, we list a summary of the functionalities that the tool can perform. Locally \u00b6 Generate new template function directories for starting new functions. Two types GCP http / pubsub . Add an existing function to the function registry to be run and deployed as functions native to the package. Build pre-generated, validated and locally existing functions using Docker. Operate ( deploy / remove ) Google Cloud Platform functions from a local machine. Store information about the built, run and deployed functions locally for reference and configuration. Print out information about functions and their statuses (Build/Deployed/Running) using the list command. Log function history using a log file stored on your local device. GCP \u00b6 Deploy locally existing functions as cloud functions. Limited to two types - http and pubsub . Delete functions deployed to GCP using this package. Additional Context \u00b6 Anyone interested in additional details is invited to view the extended source of documentation directly in Github. Proposals, ADRs for people seriously inquisitive about how we built this project.","title":"Introduction"},{"location":"#resources","text":"GitHub: https://github.com/Katolus/functions PyPI: https://pypi.org/project/functions-cli/ License: MIT","title":"Resources"},{"location":"#features","text":"The project is still under deep development, and there is still much work to be done even to reach the base quality. Nonetheless, we believe there is value in using it as it is if it fits your needs and requirements (Python + Linux). Feedback, issues and request are more than welcome. See the road map to see how our vision might need your future interest. In the following sections, we list a summary of the functionalities that the tool can perform.","title":"Features"},{"location":"#locally","text":"Generate new template function directories for starting new functions. Two types GCP http / pubsub . Add an existing function to the function registry to be run and deployed as functions native to the package. Build pre-generated, validated and locally existing functions using Docker. Operate ( deploy / remove ) Google Cloud Platform functions from a local machine. Store information about the built, run and deployed functions locally for reference and configuration. Print out information about functions and their statuses (Build/Deployed/Running) using the list command. Log function history using a log file stored on your local device.","title":"Locally"},{"location":"#gcp","text":"Deploy locally existing functions as cloud functions. Limited to two types - http and pubsub . Delete functions deployed to GCP using this package.","title":"GCP"},{"location":"#additional-context","text":"Anyone interested in additional details is invited to view the extended source of documentation directly in Github. Proposals, ADRs for people seriously inquisitive about how we built this project.","title":"Additional Context"},{"location":"environment_support/","text":"Due to limited amount of resources and a narrow development scope, functions are available/working on a limited subset of environments (OS + runtime). Operating systems \u00b6 OS name Status Was tested? Ubuntu(Linux) Available Yes macOS Available Yes - Mildly Windows Unknown No Programming languages and runtime versions \u00b6 There are several places where a language limitation might be enforced by our code. Locally \u00b6 \"Functions\" managed by the functions package are run by docker and therefore require correct execution scope. Because of execution scope for various languages requires separate implementations, the current support is limited. At the moment this is limited to Python . That said, since the scope is defined in the generated Dockerfile , there is nothing stopping you from writing your own Dockerfile and support your own execution scope. GCP \u00b6 Because cloud functions have a limited runtime set , we need to limit these versions as well. Here is an estimate of what runtimes are available. Language Version Value Was tested? Python 3.7 python37 Yes Python 3.8 python38 Yes Python 3.9 python39 Yes Node 10 nodejs10 No Node 12 nodejs12 No Node 14 nodejs14 No Node 16 nodejs16 No Java 11 java11 No Go 1.11 go111 No Go 1.13 go113 No Go 1.16 go116 No .NET Core 3.1 dotnet3 No PHP 7.4 php74 No Ruby 2.6 ruby26 No Ruby 2.7 ruby27 No Our goal is to find a solution to get this information from an underlying tool, but it is not always possible so we need to bottleneck it at our package level. We are completely aware that it is not a perfect solution, but are trying to be as transparent as possible.","title":"Environment support"},{"location":"environment_support/#operating-systems","text":"OS name Status Was tested? Ubuntu(Linux) Available Yes macOS Available Yes - Mildly Windows Unknown No","title":"Operating systems"},{"location":"environment_support/#programming-languages-and-runtime-versions","text":"There are several places where a language limitation might be enforced by our code.","title":"Programming languages and runtime versions"},{"location":"environment_support/#locally","text":"\"Functions\" managed by the functions package are run by docker and therefore require correct execution scope. Because of execution scope for various languages requires separate implementations, the current support is limited. At the moment this is limited to Python . That said, since the scope is defined in the generated Dockerfile , there is nothing stopping you from writing your own Dockerfile and support your own execution scope.","title":"Locally"},{"location":"environment_support/#gcp","text":"Because cloud functions have a limited runtime set , we need to limit these versions as well. Here is an estimate of what runtimes are available. Language Version Value Was tested? Python 3.7 python37 Yes Python 3.8 python38 Yes Python 3.9 python39 Yes Node 10 nodejs10 No Node 12 nodejs12 No Node 14 nodejs14 No Node 16 nodejs16 No Java 11 java11 No Go 1.11 go111 No Go 1.13 go113 No Go 1.16 go116 No .NET Core 3.1 dotnet3 No PHP 7.4 php74 No Ruby 2.6 ruby26 No Ruby 2.7 ruby27 No Our goal is to find a solution to get this information from an underlying tool, but it is not always possible so we need to bottleneck it at our package level. We are completely aware that it is not a perfect solution, but are trying to be as transparent as possible.","title":"GCP"},{"location":"idea/","text":"Here you can find additional context on purpose behind making this project and some of its criteria, expectations and scope. Quick Pitch \u00b6 functions - a command line tool that helps manage functions as a service (FaaS) components locally and remotely. Background \u00b6 If you are a developer working with any cloud providers, the chance is, you would have heard about serverless functions. You can use them to run small, independent components that can scale on demand. Their scope is usually that of a single task. Examples include: building a single point API, building a triggered pipeline, connecting to a resource etc... It is a fantastic piece of technology that can decouple large systems and support a wide variety of cases. Generally, it is easy to deploy a simple serverless function as a template version to fit your basic needs. It gets a little more complicated if you face a task that is out of the ordinary. Questions emerge. How do you keep track of your work? What was deployed or what was run. How do you deploy the function? How do you test it? It is not easy to handle all that using a standard tool like the gcloud command-line tool, and it is not even close to being fast. Usually, you need to deploy the function to see any results. Some providers offer helpful libraries/tools that allow you to run your serverless functions locally, but even that quickly gets complicated and requires you to learn another repository and its documentation. Even if you pass through, the automations you built will be highly specific to the provider you are using by which you are locked in. One of the things that made HashiCorp products so great is that they allow for flexibility. Flexibility and modularity are becoming far more important nowadays than it ever was. In an attempt to tackle all these pain-points and make any serverless task a much more fun experience, we propose building a software tool that takes care of all the local environment, deployment, tracking, logging and provider-specific logic and gives a developer a homogeneous CLI interface to interact with their FaaS components. A tool that takes away the complexity and gives back an intuitive work tool for everyone to use. Progress so far \u00b6 The project started as a solo project in between jobs. It's scope was massively undercut from the start, but with time and experience, the spectrum became something that we can track with much higher confidence. The project is a battleground for growing developer skills, and it has been treated like that, still yet to see its first release. Objectives \u00b6 Fail and learn. Experiment and test out various ideas. Provide value to at least one person. Get people interested. Principle Values \u00b6 Easy to Use. Safe. Simple. Timeframe \u00b6 Stage Summary Delivery First Release The first release targets a stable alpha version with enough functionalities to test the idea in action. Planned for the end of 2021 Engineering budget \u00b6 In the first stage, the project is being developed by a single person as a side project between jobs. Since that person has other commitments, the project has taken a lower priority, and work on it goes slower than anticipated. So if you believe in this project, the repository is set up to support community contributions if people value it enough to contribute. Monitoring and Evaluation \u00b6 The project is being reviewed at least every month to reevaluate timeframes, view project interactions and adjust documentation accordingly. Lessons learned \u00b6 Beyond elemental learnings such as how to pick a suitable license or which tool to use to perform a specific task, here lay the lessons with a broader, more generic scope: It takes a lot of time, effort and brainpower to build a quality project. The scope is always bigger than you initially thought to be. It is vital to build and bring tools to the project. Planning out the scope and writing a comprehensive overview is reasonably the most crucial step. Otherwise, you are unsure what you are trying to do or how the project should be structured. It is worth the effort . Documentation is as important if not more important than code.","title":"Idea"},{"location":"idea/#quick-pitch","text":"functions - a command line tool that helps manage functions as a service (FaaS) components locally and remotely.","title":"Quick Pitch"},{"location":"idea/#background","text":"If you are a developer working with any cloud providers, the chance is, you would have heard about serverless functions. You can use them to run small, independent components that can scale on demand. Their scope is usually that of a single task. Examples include: building a single point API, building a triggered pipeline, connecting to a resource etc... It is a fantastic piece of technology that can decouple large systems and support a wide variety of cases. Generally, it is easy to deploy a simple serverless function as a template version to fit your basic needs. It gets a little more complicated if you face a task that is out of the ordinary. Questions emerge. How do you keep track of your work? What was deployed or what was run. How do you deploy the function? How do you test it? It is not easy to handle all that using a standard tool like the gcloud command-line tool, and it is not even close to being fast. Usually, you need to deploy the function to see any results. Some providers offer helpful libraries/tools that allow you to run your serverless functions locally, but even that quickly gets complicated and requires you to learn another repository and its documentation. Even if you pass through, the automations you built will be highly specific to the provider you are using by which you are locked in. One of the things that made HashiCorp products so great is that they allow for flexibility. Flexibility and modularity are becoming far more important nowadays than it ever was. In an attempt to tackle all these pain-points and make any serverless task a much more fun experience, we propose building a software tool that takes care of all the local environment, deployment, tracking, logging and provider-specific logic and gives a developer a homogeneous CLI interface to interact with their FaaS components. A tool that takes away the complexity and gives back an intuitive work tool for everyone to use.","title":"Background"},{"location":"idea/#progress-so-far","text":"The project started as a solo project in between jobs. It's scope was massively undercut from the start, but with time and experience, the spectrum became something that we can track with much higher confidence. The project is a battleground for growing developer skills, and it has been treated like that, still yet to see its first release.","title":"Progress so far"},{"location":"idea/#objectives","text":"Fail and learn. Experiment and test out various ideas. Provide value to at least one person. Get people interested.","title":"Objectives"},{"location":"idea/#principle-values","text":"Easy to Use. Safe. Simple.","title":"Principle Values"},{"location":"idea/#timeframe","text":"Stage Summary Delivery First Release The first release targets a stable alpha version with enough functionalities to test the idea in action. Planned for the end of 2021","title":"Timeframe"},{"location":"idea/#engineering-budget","text":"In the first stage, the project is being developed by a single person as a side project between jobs. Since that person has other commitments, the project has taken a lower priority, and work on it goes slower than anticipated. So if you believe in this project, the repository is set up to support community contributions if people value it enough to contribute.","title":"Engineering budget"},{"location":"idea/#monitoring-and-evaluation","text":"The project is being reviewed at least every month to reevaluate timeframes, view project interactions and adjust documentation accordingly.","title":"Monitoring and Evaluation"},{"location":"idea/#lessons-learned","text":"Beyond elemental learnings such as how to pick a suitable license or which tool to use to perform a specific task, here lay the lessons with a broader, more generic scope: It takes a lot of time, effort and brainpower to build a quality project. The scope is always bigger than you initially thought to be. It is vital to build and bring tools to the project. Planning out the scope and writing a comprehensive overview is reasonably the most crucial step. Otherwise, you are unsure what you are trying to do or how the project should be structured. It is worth the effort . Documentation is as important if not more important than code.","title":"Lessons learned"},{"location":"roadmap/","text":"To understand what this project is about, check out the idea section . Moving forward, our goal is to provide a valuable, tested, and robust tool that others can use to their benefit. First release and core project progress can be tracked here . Once we reach the base quality, the are other project and idea that we hope to work on, given that functions starts providing value and receives required traction. We plan to grow its capabilities, having some short and medium term goals in mind. Mission \u00b6 Make Functions as a Service (FaaS) easy to work with. Short-term - Current focus \u00b6 Clean up \u00b6 Initial prototype bursting left chunks on inconsistent code. We want to bring cohesion and best practices to the first version of the project so that the technical debt does not creep on us in the future. Status : Planning AWS lambda support \u00b6 We want to add support for AWS lambda functions locally and deployment. Status : Planning Runtime support \u00b6 Currently, the support for runtimes is quite limited due to the narrow scope of the initial implementation. We want to ensure anyone can use whichever runtime they want, given that it is supported. Status : Planning Test coverage \u00b6 As with any idea that made sense (will see about that) in the prototyping phase, we want to make sure that is well tested moving forward. Status : Planning Mid-term - What comes next \u00b6 Build-up documentation \u00b6 It is a shame how much documentation is missing. We want to make sure that there are decision records , components descriptions , examples and more, which users and developers can quickly reference at any time. Status : Ongoing development Custom commands and scripts \u00b6 We want to enable the user to create their enhancements to the functioning of the package by allowing the definition of custom scripts and commands. Status : Idea GitHub source URL as a source path for a function \u00b6 We want to support using a Github URL as a source for your function's source code. Status : Idea Evaluate Typer \u00b6 Despite the initial hype around this project, it does seem to be left out at the moment. The base package click seems to have much better support and extensibility. Status : Idea Docker executable \u00b6 We think that using python to execute the functions works well, however has it's limitations. Specifically when installing dependencies required to run deployment actions. All this can be neatly wrapped around with a Docker image, which needs to be in the scope of the package either way. Much easier to manage system interactions contained within an image. Status : Idea How to Get Involved \u00b6 We try to organize our project goals with GitHub projects. If there is an existing GitHub project, it is an excellent place to start aiding. If not, perhaps you can offer some expertise and lead an implementation forward. As always, reach out if you fancy a discussion.","title":"Roadmap"},{"location":"roadmap/#mission","text":"Make Functions as a Service (FaaS) easy to work with.","title":"Mission"},{"location":"roadmap/#short-term---current-focus","text":"","title":"Short-term - Current focus"},{"location":"roadmap/#clean-up","text":"Initial prototype bursting left chunks on inconsistent code. We want to bring cohesion and best practices to the first version of the project so that the technical debt does not creep on us in the future. Status : Planning","title":"Clean up"},{"location":"roadmap/#aws-lambda-support","text":"We want to add support for AWS lambda functions locally and deployment. Status : Planning","title":"AWS lambda support"},{"location":"roadmap/#runtime-support","text":"Currently, the support for runtimes is quite limited due to the narrow scope of the initial implementation. We want to ensure anyone can use whichever runtime they want, given that it is supported. Status : Planning","title":"Runtime support"},{"location":"roadmap/#test-coverage","text":"As with any idea that made sense (will see about that) in the prototyping phase, we want to make sure that is well tested moving forward. Status : Planning","title":"Test coverage"},{"location":"roadmap/#mid-term---what-comes-next","text":"","title":"Mid-term - What comes next"},{"location":"roadmap/#build-up-documentation","text":"It is a shame how much documentation is missing. We want to make sure that there are decision records , components descriptions , examples and more, which users and developers can quickly reference at any time. Status : Ongoing development","title":"Build-up documentation"},{"location":"roadmap/#custom-commands-and-scripts","text":"We want to enable the user to create their enhancements to the functioning of the package by allowing the definition of custom scripts and commands. Status : Idea","title":"Custom commands and scripts"},{"location":"roadmap/#github-source-url-as-a-source-path-for-a-function","text":"We want to support using a Github URL as a source for your function's source code. Status : Idea","title":"GitHub source URL as a source path for a function"},{"location":"roadmap/#evaluate-typer","text":"Despite the initial hype around this project, it does seem to be left out at the moment. The base package click seems to have much better support and extensibility. Status : Idea","title":"Evaluate Typer"},{"location":"roadmap/#docker-executable","text":"We think that using python to execute the functions works well, however has it's limitations. Specifically when installing dependencies required to run deployment actions. All this can be neatly wrapped around with a Docker image, which needs to be in the scope of the package either way. Much easier to manage system interactions contained within an image. Status : Idea","title":"Docker executable"},{"location":"roadmap/#how-to-get-involved","text":"We try to organize our project goals with GitHub projects. If there is an existing GitHub project, it is an excellent place to start aiding. If not, perhaps you can offer some expertise and lead an implementation forward. As always, reach out if you fancy a discussion.","title":"How to Get Involved"},{"location":"administration/","text":"This section includes background on how we administrate our functions project. We hope that the information noted here brings peace and trust in using the tool. You might even like it so much that you decide to help out! The Origins \u00b6 We created functions to address the accumulating difficulty in building features in an event ecosystem (PubSub). It started as a side project, meant to satisfy minimal requirements of being useful in the shortest time. With time it evolved to an open-source level aspiration. A swing at building a tool, used and contributed to by many. Maintenance \u00b6 These are early days, and the project is at its infant years. It lacks structure, resources and a tested sense of purpose. Hopefully, it will gain these over time. It is maintained on a casual basis, addressing issues here and there as the motivation comes in . If the project proves to be redundant, it will be abandoned to make space for other, more capable projects. So if you are using functions and don't want to lose it, head to any resources and show your appreciation. It will give us so much required motivation and keep us going. Governance \u00b6 All final decisions, features and future focus are made by Piotr Katolik , the architect of this project.","title":"Administration"},{"location":"administration/#the-origins","text":"We created functions to address the accumulating difficulty in building features in an event ecosystem (PubSub). It started as a side project, meant to satisfy minimal requirements of being useful in the shortest time. With time it evolved to an open-source level aspiration. A swing at building a tool, used and contributed to by many.","title":"The Origins"},{"location":"administration/#maintenance","text":"These are early days, and the project is at its infant years. It lacks structure, resources and a tested sense of purpose. Hopefully, it will gain these over time. It is maintained on a casual basis, addressing issues here and there as the motivation comes in . If the project proves to be redundant, it will be abandoned to make space for other, more capable projects. So if you are using functions and don't want to lose it, head to any resources and show your appreciation. It will give us so much required motivation and keep us going.","title":"Maintenance"},{"location":"administration/#governance","text":"All final decisions, features and future focus are made by Piotr Katolik , the architect of this project.","title":"Governance"},{"location":"administration/decisions/","text":"We strive to deliver a consistent, trusty solution for stable development. Our project is built on a structured change request system developed by the team. We impose this process to assure work is researched, reviewed, prioritized and documented with sufficient context and expectations. So, how do we make decisions? \u00b6 We use the following process. Each of the steps assumes a positive outcome from the stage before. Write a proposal . Review the proposal. Implement a prototype. Evaluate changes and implications through a functional review. Categorize change as a feature or architectural decision. Prior to any release, move accepted proposals into respective categories of documents - fdrs or adrs . Hopefully after this work, all the changes are discussed and the impact is flushed out. Proposals \u00b6 Documents based on the proposals template . The document describes the context and a problem that a given change is to update. Proposals include at least one solution option and supplement a range of research resources. ADRs - Architectural decision records \u00b6 An Architectural Decision (AD) is a software design choice that addresses a functional or non-functional requirement that is architecturally significant. - Source . Documents based on the adrs template . The document targets change of an architectural nature. FDRs - Feature decision records \u00b6 Feature documents explain why features or parts of the applications not categorized as architecture were our focus. They give context on - Why? and How?","title":"Decisions"},{"location":"administration/decisions/#so-how-do-we-make-decisions","text":"We use the following process. Each of the steps assumes a positive outcome from the stage before. Write a proposal . Review the proposal. Implement a prototype. Evaluate changes and implications through a functional review. Categorize change as a feature or architectural decision. Prior to any release, move accepted proposals into respective categories of documents - fdrs or adrs . Hopefully after this work, all the changes are discussed and the impact is flushed out.","title":"So, how do we make decisions?"},{"location":"administration/decisions/#proposals","text":"Documents based on the proposals template . The document describes the context and a problem that a given change is to update. Proposals include at least one solution option and supplement a range of research resources.","title":"Proposals"},{"location":"administration/decisions/#adrs---architectural-decision-records","text":"An Architectural Decision (AD) is a software design choice that addresses a functional or non-functional requirement that is architecturally significant. - Source . Documents based on the adrs template . The document targets change of an architectural nature.","title":"ADRs - Architectural decision records"},{"location":"administration/decisions/#fdrs---feature-decision-records","text":"Feature documents explain why features or parts of the applications not categorized as architecture were our focus. They give context on - Why? and How?","title":"FDRs - Feature decision records"}]}